---
layout: post
title: 读书笔记 - 代码的未来
date: 2013-07-06 17:13
comments: true
categories: book
---

# 1 编程的时间和空间

## 1.1 编程的本质

* 编程的本质是思考
* 编程可以体会到创造的乐趣
* 快速提高的性能改变了社会
* 摩尔定律的局限
* 社会化与编程

## 1.2 未来预测

* 极限
* 价格
* 性能
* 容量
* 带宽

# 2 编程语言的过去、现在和未来

## 2.1 编程语言的世界

* 打孔纸袋
* 机器语言
* 汇编语言

### 编程语言的历史

1. FORTRAN
2. COBOL
3. Lisp
4. SNOBOL
5. Prolog，Haskell
6. C，C++，Java，JavaScript，Ruby，Perl，Python，PHP

### 未来的编程语言

* 并行化
* 简洁

* 变化不大
* 不会再用编程语言来编程
* 更抽象的编程语言

## 2.2 DSL(特定领域语言)

### 外部DSL和内部DSL

* 外部DSL：由专用的语言引擎来实现的DSL，称为外部DSL，如XML，正则表达式，SQL，JSON等
* 内部DSL：在现有语言中实现DSL，如在Ruby，Lisp中实现DSL

### DSL的优势

* 节约时间
* 简洁
* 提高效率
* 抽象

### DSL设计的构成要素

* 上下文 Context
* 语句 Sentence
* 单位 Unit
* 词汇 Vocabulary
* 层次结构 Hierarchy

## 2.3 元编程

### Meta，Reflection

* meta，，元，表示对自身的描述
* 描述数据所具有的结构的数据，就是关于数据本身的数据，被称为元数据

### 数据和程序

* Lisp
* 宏

### 元编程的可能性与危险性

* 在程序运行时对程序本身进行操作
* 灵活性

## 2.4 内存管理

### 看似无限的内存

* 垃圾回收机制
* 虚拟内存

## GC的3种基本方式

* 标记清除方式
* 复制收集方式
* 引用计数方式

### 进一步改良的应用方式

* 分代回收
* 增量回收
* 并行回收
* GC大统一理论

## 2.5 异常处理

* 凡是可能出错的事总会出错
* 用特殊值返回错误
* 容易忽略错误处理
* 产生异常
* 更高级的异常处理
* Ruby中的后处理保证
* 其他语言的异常处理
* Java的检查型异常
* Icon的异常与真假值
* Eiffel的Design By Contract (契约式设计)
* 异常与错误值

## 2.6 闭包

* 函数对象
* 高阶函数
* 用函数参数提高通用性 (qsort)
* 函数指针的局限 (函数无法访问到外部局部变量)
* 作用域：变量可见范围
* 生存周期：变量的存在范围
* 闭包与面向对象(过程与数据的结合)

### Ruby与JavaScript的区别

* Ruby中只有方法没有函数
* 过程对象(Proc)不是函数，需要调用call方法

# 3 编程语言的新潮流

## 3.1 语言的设计

* 服务端和客户端
* Java在服务端成功的理由：可移植性，功能强大，高性能，丰富的库
* JavaScript在客户端，性能显著提升
* 服务端的Ruby
* 服务端的Go
* 动态类型的立场：数据拥有类型，且只有数据拥有类型
* 静态类型的立场：数据拥有类型，存放数据的变量，表达式也拥有类型，且类型在编译时就固定了
* 动态类型的有点：简洁，灵活性高
* 静态类型的优点：容易发现bug，性能高
* 结构子类型 (Structural Subtyping)

## 3.2 Go

* 新的
* 实验性的
* 并发的
* 带垃圾回收
* 系统语言

## 语言

* 无继承式面向对象
* 多值与多重赋值
* 并发编程

## 3.3 Dart

* 更现代，更安全，高速的语言
* 基于类的对象系统
* 非强制性静态类型

## 3.4 CoffeeScript

* JavaScript：最普及的语言，被误解最多的语言，显著高速化的语言
* 其他略

## 3.5 Lua

* 数据类型
* 函数
* 表
* 元表
* 方法调用的实现
* 基于原型编程
* 嵌入式语言(一个进程可以容纳多个解释器)
* 嵌入式ruby(mruby)

# 4 云计算时代的编程

## 4.1 可扩展性

* K, M, G, T, P, E, Z, Y
* 大量数据的查找
* 二分法查找
* 散列表（链地址法和开放地址法）
* 布隆过滤器(概率算法)
* 分布式散列表
* MapReduce

## 4.2 C10K问题

* 同时工作的进程不会那么多吧
* 内存的容量足够用来处理所创建的进程和线程的数量吧
* 同时打开的文件描述符的数量不会有那么多吧
* 要对多个文件描述符进行监视，用select系统调用就足够了吧
* 解决问题：使用epoll，使用libev框架，使用EventMachine等

## 4.3 HashFold

代码及分析略。。

## 4.4 进程间通信

* 进程和线程（线程共享内存空间，是否利用多核和实现有关）
* 进程间通信（管道，消息，信号量，共享内存，TCP，UDP，UNIX域套接字）
* UDP的特点（数据以数据包为单位发送，没有纠错机制，不需要连接，高速）
* TCP的特点（数据以字节流处理，无法按照包为单位查看）

## 4.5 Rack与Unicorn

* Rack中间件
* 应用服务器的问题（响应缓慢，内存开销，分配不均衡，重启缓慢，部署缓慢）
* Unicorn如何解决这些问题 略

# 5 支撑大数据的数据存储技术

## 5.1 键 - 值存储

* Hash和DBM
* ACID：原子性，一致性，隔离性，持久性 (Atomicity, Consistency, Isolation, Durability)
* CAP原则：一致性，可用性，分裂容忍性 (Consistency, Availability, Partition Tolerance) 只能同时满足2个。。
* BASE原则：可用性，严密性，最终一致性(Basically Available, Soft-state, Eventually consistent)

## 5.2 NoSQL

* No SQL vs Not only SQL
* 键 - 值 存储数据库，面向文档数据库，面向对象数据库
* CouchDB和MongoDB

## 5.3 用Ruby来操作MongoDB

略

## 5.4 SQL数据库的反击

* MySQL的存储引擎Spider，逻辑和数据库相分离，可维护性高
* 斯通布雷克提出：NoSQL的优势在于性能和灵活性，NoSQL的性能优于SQL这一说法，并非在所有情况下都成立，性能问题于SQL和ACID无关
* 性能瓶颈：日志，事务锁，内存锁，缓存管理

## 5.5 memcached和它的伙伴们

* 用户高速访问的缓存
* memcached的不足：数据长度，分布式，持久性
* Redis

# 6 多核时代的编程

## 6.1 摩尔定律

* 呈几何级数增长
* 提高性能
* 摩尔定律的极限

## 6.2 UNIX管道

* 阿姆达尔定律
* 多核编程

## 6.3 非阻塞I/O

略。。

## 6.4 node.js

* 事件驱动

## ZeroMQ

* 分布式进程间通信